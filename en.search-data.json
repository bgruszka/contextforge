{"/docs/":{"data":{"":"Welcome to the ContextForge documentation. Learn how to install, configure, and use ContextForge for automatic HTTP header propagation in your Kubernetes clusters.","key-features#Key Features":"Zero Code Changes ‚Äî Just add Kubernetes annotations Lightweight ‚Äî ~10MB memory, \u003c5ms latency per request Framework Agnostic ‚Äî Works with any HTTP client in any language Kubernetes Native ‚Äî Uses standard admission webhooks and CRDs Production Ready ‚Äî Battle-tested with health checks and graceful shutdown","quick-navigation#Quick Navigation":"Getting StartedInstall and configure ContextForge in 5 minutes InstallationDetailed installation options and requirements ConfigurationAnnotations, CRDs, and advanced settings How It WorksArchitecture and technical deep-dive ExamplesReal-world use cases and code samples","what-is-contextforge#What is ContextForge?":"ContextForge is a Kubernetes operator that injects a lightweight sidecar proxy into your pods. This proxy automatically captures HTTP headers from incoming requests and propagates them to all outgoing HTTP calls ‚Äî without requiring any code changes in your applications."},"title":"Documentation"},"/docs/changelog/":{"data":{"":"All notable changes to ContextForge are documented here.\nThis changelog is automatically updated with each release.","documentation#Documentation":"Getting started guide Installation instructions Configuration reference Architecture documentation","features#Features":"Sidecar injection via mutating admission webhook HTTP header propagation through service chains Pod annotations for configuration (ctxforge.io/enabled, ctxforge.io/headers) Lightweight proxy with \u003c5ms latency overhead Health checks and graceful shutdown Helm chart for easy installation","v010-initial-release#v0.1.0 (Initial Release)":""},"title":"Changelog"},"/docs/configuration/":{"data":{"":"ContextForge can be configured through pod annotations and the HeaderPropagationPolicy CRD.","advanced-header-rules-header_rules#Advanced Header Rules (HEADER_RULES)":"For advanced configuration including header generation and filtering, use HEADER_RULES:\nHEADER_RULES='[ {\"name\": \"x-request-id\", \"generate\": true, \"generatorType\": \"uuid\"}, {\"name\": \"x-tenant-id\"}, {\"name\": \"x-api-key\", \"pathRegex\": \"^/api/.*\", \"methods\": [\"POST\", \"PUT\"]} ]'","advanced-mode-with-header-rules#Advanced Mode (with header-rules)":"apiVersion: apps/v1 kind: Deployment metadata: name: my-service spec: template: metadata: labels: ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/target-port: \"3000\" ctxforge.io/header-rules: | [ {\"name\": \"x-request-id\", \"generate\": true, \"generatorType\": \"uuid\"}, {\"name\": \"x-tenant-id\"}, {\"name\": \"x-debug\", \"pathRegex\": \"^/api/.*\", \"methods\": [\"POST\", \"PUT\"]} ] spec: containers: - name: app image: my-app:latest ports: - containerPort: 3000","crd-fields#CRD Fields":"","disable-injection-for-a-namespace#Disable Injection for a Namespace":"To prevent sidecar injection in a namespace:\napiVersion: v1 kind: Namespace metadata: name: kube-system labels: ctxforge.io/injection: disabled","enable-injection-by-default#Enable Injection by Default":"To inject sidecars into all pods in a namespace (without requiring annotations):\napiVersion: v1 kind: Namespace metadata: name: production labels: ctxforge.io/injection: enabled When namespace-level injection is enabled, you can still opt-out individual pods by setting ctxforge.io/enabled: \"false\" annotation.","example#Example":"","generator-types#Generator Types":"Type Format Example uuid UUID v4 550e8400-e29b-41d4-a716-446655440000 ulid ULID (sortable) 01ARZ3NDEKTSV4RRFFQ69G5FAV timestamp RFC3339Nano 2025-01-01T12:00:00.123456789Z","header-rule-fields#Header Rule Fields":"Field Type Default Description name string (required) HTTP header name generate bool false Auto-generate if header is missing generatorType string uuid Generator: uuid, ulid, or timestamp propagate bool true Whether to propagate this header pathRegex string - Regex pattern to match request paths methods []string - HTTP methods to match (e.g., [\"GET\", \"POST\"])","headerpropagationpolicy-crd#HeaderPropagationPolicy CRD":"For more advanced configuration, use the HeaderPropagationPolicy custom resource:\napiVersion: ctxforge.ctxforge.io/v1alpha1 kind: HeaderPropagationPolicy metadata: name: default-policy namespace: default spec: selector: matchLabels: app: my-service propagationRules: - headers: - name: x-request-id generate: true # Auto-generate if missing generatorType: uuid # UUID generator - name: x-tenant-id propagate: true # Always propagate - name: x-debug propagate: true pathRegex: \".*\" # Apply to all paths methods: # Apply to these methods - GET - POST - PUT","helm-chart-values#Helm Chart Values":"Key configuration options in values.yaml:\n# Operator configuration operator: replicas: 1 image: repository: ghcr.io/bgruszka/contextforge-operator tag: latest resources: requests: cpu: 100m memory: 128Mi # Proxy sidecar defaults proxy: image: repository: ghcr.io/bgruszka/contextforge-proxy tag: latest resources: requests: cpu: 50m memory: 32Mi limits: cpu: 200m memory: 64Mi # Webhook configuration webhook: failurePolicy: Fail # or Ignore timeoutSeconds: 10 certManager: enabled: false # Set to true if using cert-manager # RBAC rbac: create: true # Service Account serviceAccount: create: true name: \"\"","namespace-configuration#Namespace Configuration":"","optional-annotations#Optional Annotations":"Annotation Default Description ctxforge.io/headers \"\" Comma-separated list of headers to propagate (simple mode) ctxforge.io/header-rules \"\" JSON array of advanced header rules (see Advanced Header Rules) ctxforge.io/target-port 8080 Port of your application container Use ctxforge.io/headers for simple header propagation. Use ctxforge.io/header-rules when you need header generation, path filtering, or method filtering.","pod-annotations#Pod Annotations":"","proxy-environment-variables#Proxy Environment Variables":"The sidecar proxy is configured through environment variables (set automatically by the operator):\nVariable Default Description HEADERS_TO_PROPAGATE \"\" Comma-separated header names (simple mode) HEADER_RULES \"\" JSON array of advanced header rules (alternative to HEADERS_TO_PROPAGATE) TARGET_HOST localhost:8080 Application container address PROXY_PORT 9090 Proxy listen port LOG_LEVEL info Log level: debug, info, warn, error METRICS_PORT 9091 Prometheus metrics port","required-annotations#Required Annotations":"Annotation Value Description ctxforge.io/enabled \"true\" Enables sidecar injection for this pod","simple-mode#Simple Mode":"apiVersion: apps/v1 kind: Deployment metadata: name: my-service spec: template: metadata: labels: ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-request-id,x-tenant-id,x-correlation-id\" ctxforge.io/target-port: \"3000\" spec: containers: - name: app image: my-app:latest ports: - containerPort: 3000","specpropagationrules#\u003ccode\u003espec.propagationRules\u003c/code\u003e":"List of rules defining which headers to propagate:\nField Type Description headers list Headers to propagate headers[].name string Header name (case-insensitive) headers[].generate bool Generate header if missing headers[].generatorType string Generator type: uuid, ulid, timestamp headers[].propagate bool Whether to propagate (default: true) pathRegex string Regex to match request paths methods list HTTP methods to apply rule to","specselector#\u003ccode\u003espec.selector\u003c/code\u003e":"Selects which pods this policy applies to:\nselector: matchLabels: app: my-service environment: production"},"title":"Configuration"},"/docs/examples/":{"data":{"":"Real-world examples and use cases for ContextForge.","compliance--audit-trail#Compliance \u0026amp; Audit Trail":"Maintain audit trails for payment processing:\napiVersion: apps/v1 kind: Deployment metadata: name: payment-processor spec: template: metadata: labels: ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-audit-id,x-transaction-id,x-user-id,x-session-id\" spec: containers: - name: payment-processor image: payment-processor:latest Application logging:\n// In your application code func ProcessPayment(ctx context.Context, amount float64) error { auditID := ctx.Value(\"x-audit-id\") transactionID := ctx.Value(\"x-transaction-id\") log.Info(\"Processing payment\", \"audit_id\", auditID, \"transaction_id\", transactionID, \"amount\", amount, ) // Process payment... }","custom-port-configuration#Custom Port Configuration":"If your app runs on a non-standard port:\napiVersion: apps/v1 kind: Deployment metadata: name: custom-port-app spec: template: metadata: labels: ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-request-id\" ctxforge.io/target-port: \"3000\" # Node.js default port spec: containers: - name: nodejs-app image: nodejs-app:latest ports: - containerPort: 3000","developer-debugging#Developer Debugging":"Add developer ID header to trace requests through staging:\n# Development namespace configuration apiVersion: v1 kind: Namespace metadata: name: staging labels: ctxforge.io/injection: enabled --- # All pods in staging get these headers propagated apiVersion: ctxforge.ctxforge.io/v1alpha1 kind: HeaderPropagationPolicy metadata: name: dev-headers namespace: staging spec: selector: matchLabels: {} # Match all pods propagationRules: - headers: - name: x-dev-id - name: x-request-id generate: true generatorType: uuid Developer workflow:\n# Add your dev ID to requests curl -H \"x-dev-id: alice\" https://staging.example.com/api/orders # View only your requests in logs kubectl logs -l app=order-service -n staging | grep \"x-dev-id: alice\"","feature-flags#Feature Flags":"Propagate feature flag context for A/B testing:\napiVersion: apps/v1 kind: Deployment metadata: name: feature-service spec: template: metadata: labels: ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-feature-flags,x-experiment-id,x-variant\" spec: containers: - name: feature-service image: feature-service:latest","full-example-e-commerce-platform#Full Example: E-Commerce Platform":"A complete example showing header propagation across an e-commerce platform:\n# API Gateway - entry point apiVersion: apps/v1 kind: Deployment metadata: name: api-gateway namespace: ecommerce spec: replicas: 3 template: metadata: labels: app: api-gateway ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-request-id,x-tenant-id,x-user-id,x-session-id\" spec: containers: - name: gateway image: ecommerce/api-gateway:v1.2.0 ports: - containerPort: 8080 --- # Product Service apiVersion: apps/v1 kind: Deployment metadata: name: product-service namespace: ecommerce spec: replicas: 2 template: metadata: labels: app: product-service ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-request-id,x-tenant-id,x-user-id\" spec: containers: - name: products image: ecommerce/product-service:v2.0.1 --- # Order Service apiVersion: apps/v1 kind: Deployment metadata: name: order-service namespace: ecommerce spec: replicas: 2 template: metadata: labels: app: order-service ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-request-id,x-tenant-id,x-user-id,x-session-id\" spec: containers: - name: orders image: ecommerce/order-service:v1.5.0 --- # Payment Service apiVersion: apps/v1 kind: Deployment metadata: name: payment-service namespace: ecommerce spec: replicas: 2 template: metadata: labels: app: payment-service ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-request-id,x-tenant-id,x-user-id,x-transaction-id\" spec: containers: - name: payments image: ecommerce/payment-service:v1.0.3 --- # Notification Service apiVersion: apps/v1 kind: Deployment metadata: name: notification-service namespace: ecommerce spec: replicas: 1 template: metadata: labels: app: notification-service ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-request-id,x-user-id\" spec: containers: - name: notifications image: ecommerce/notification-service:v1.1.0 Request flow:\nflowchart TD Customer[\"Customer places order\"] Gateway[\"API Gatewaysets x-request-idextracts x-user-id from JWT\"] Product[\"Product Servicevalidates inventory\"] Order[\"Order Servicecreates order\"] Payment[\"Payment Serviceprocesses payment\"] Notify[\"Notification Servicesends confirmation\"] ProductLog[\"üìù [ord-123] Checking inventory\"] OrderLog[\"üìù [ord-123] Creating order\"] PaymentLog[\"üìù [ord-123] Processing $99.99\"] NotifyLog[\"üìù [ord-123] Sending email\"] Customer --\u003e Gateway Gateway --\u003e Product Gateway --\u003e Order Gateway --\u003e Notify Order --\u003e Payment Product -.-\u003e ProductLog Order -.-\u003e OrderLog Payment -.-\u003e PaymentLog Notify -.-\u003e NotifyLog style Customer fill:#1e3a5f,stroke:#60a5fa,color:#fff style Gateway fill:#4c1d95,stroke:#a78bfa,color:#fff style Product fill:#312e81,stroke:#818cf8,color:#fff style Order fill:#312e81,stroke:#818cf8,color:#fff style Payment fill:#312e81,stroke:#818cf8,color:#fff style Notify fill:#312e81,stroke:#818cf8,color:#fff style ProductLog fill:#14532d,stroke:#4ade80,color:#fff style OrderLog fill:#14532d,stroke:#4ade80,color:#fff style PaymentLog fill:#14532d,stroke:#4ade80,color:#fff style NotifyLog fill:#14532d,stroke:#4ade80,color:#fff All services log the same x-request-id, making it easy to trace the entire order flow!","multi-tenant-saas#Multi-Tenant SaaS":"Propagate tenant ID through all services for data isolation:\napiVersion: apps/v1 kind: Deployment metadata: name: api-gateway spec: template: metadata: labels: ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-tenant-id,x-user-id\" spec: containers: - name: gateway image: api-gateway:latest --- apiVersion: apps/v1 kind: Deployment metadata: name: user-service spec: template: metadata: labels: ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-tenant-id,x-user-id\" spec: containers: - name: user-service image: user-service:latest --- apiVersion: apps/v1 kind: Deployment metadata: name: billing-service spec: template: metadata: labels: ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-tenant-id,x-user-id\" spec: containers: - name: billing-service image: billing-service:latest Flow:\nflowchart TD Gateway[\"API Gatewaysets x-tenant-id: acme-corp\"] UserSvc[\"User Servicereceives x-tenant-id\"] BillingSvc[\"Billing Servicereceives x-tenant-id\"] UserDB[\"Database queryfiltered by tenant\"] BillingDB[\"Tenant's billing dataonly\"] Gateway --\u003e UserSvc Gateway --\u003e BillingSvc UserSvc --\u003e UserDB BillingSvc --\u003e BillingDB style Gateway fill:#4c1d95,stroke:#a78bfa,color:#fff style UserSvc fill:#312e81,stroke:#818cf8,color:#fff style BillingSvc fill:#312e81,stroke:#818cf8,color:#fff","request-tracing#Request Tracing":"Track requests across microservices with correlation IDs:\napiVersion: apps/v1 kind: Deployment metadata: name: order-service spec: template: metadata: labels: ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-request-id,x-correlation-id,x-trace-id\" spec: containers: - name: order-service image: order-service:latest Viewing logs across services:\n# Find all logs for a specific request kubectl logs -l app=order-service | grep \"x-request-id: abc123\" kubectl logs -l app=payment-service | grep \"x-request-id: abc123\" kubectl logs -l app=notification-service | grep \"x-request-id: abc123\"","telepresence-integration#Telepresence Integration":"Seamlessly integrate with Telepresence for local development. When using Telepresence intercepts, the x-telepresence-intercept-id header must flow through all downstream services for proper routing:\napiVersion: apps/v1 kind: Deployment metadata: name: frontend spec: template: metadata: labels: ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-telepresence-intercept-id,x-request-id\" spec: containers: - name: frontend image: frontend:latest --- apiVersion: apps/v1 kind: Deployment metadata: name: backend-api spec: template: metadata: labels: ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-telepresence-intercept-id,x-request-id\" spec: containers: - name: backend-api image: backend-api:latest --- apiVersion: apps/v1 kind: Deployment metadata: name: database-service spec: template: metadata: labels: ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-telepresence-intercept-id,x-request-id\" spec: containers: - name: database-service image: database-service:latest Developer workflow:\n# Start Telepresence intercept on backend-api telepresence intercept backend-api --port 8080 # Now requests with your intercept header flow through the entire chain: # Frontend ‚Üí Backend API (local) ‚Üí Database Service # # Without ContextForge, only Frontend ‚Üí Backend API would be intercepted. # With ContextForge, the x-telepresence-intercept-id header propagates # to ALL downstream services, so your local backend can call # database-service and the response comes back to you! Flow with Telepresence + ContextForge:\nflowchart TD Browser[\"Browser Requestx-telepresence-intercept-id: abc123\"] Frontend[\"Frontend Service(in cluster)\"] Backend[\"Backend API\"] Local[\"Your Local Machine(intercepted!)\"] DB[\"Database Service(in cluster)\"] Response[\"Response flows backto local machine\"] Browser --\u003e Frontend Frontend --\u003e |\"ContextForgepropagates header\"| Backend Backend -.-\u003e |\"Telepresenceintercept\"| Local Local --\u003e |\"Your local code calls DBheader propagates\"| DB DB --\u003e Response Response -.-\u003e Local style Browser fill:#1e3a5f,stroke:#60a5fa,color:#fff style Frontend fill:#312e81,stroke:#818cf8,color:#fff style Backend fill:#312e81,stroke:#818cf8,color:#fff style Local fill:#14532d,stroke:#4ade80,color:#fff style DB fill:#312e81,stroke:#818cf8,color:#fff This enables true end-to-end local development where you can debug the backend while still connecting to real cluster services!"},"title":"Examples"},"/docs/getting-started/":{"data":{"":"Get ContextForge up and running in your Kubernetes cluster in just a few minutes.","enable-header-propagation#Enable Header Propagation":"To enable automatic header propagation for a pod, add the following annotations:\napiVersion: apps/v1 kind: Deployment metadata: name: my-service spec: template: metadata: labels: ctxforge.io/enabled: \"true\" annotations: ctxforge.io/enabled: \"true\" ctxforge.io/headers: \"x-request-id,x-tenant-id\" spec: containers: - name: app image: my-app:latest ports: - containerPort: 8080 What do these annotations do? ctxforge.io/enabled: \"true\" ‚Äî Tells ContextForge to inject the sidecar proxy into this pod ctxforge.io/headers ‚Äî Comma-separated list of headers to propagate","installation#Installation":"","next-steps#Next Steps":"Installation Guide ‚Äî Detailed installation options Configuration ‚Äî All available annotations and settings How It Works ‚Äî Understand the architecture Examples ‚Äî Real-world use cases","prerequisites#Prerequisites":"Before you begin, ensure you have:\nKubernetes cluster version 1.24 or later Helm version 3.0 or later kubectl configured to access your cluster cluster-admin permissions (for installing CRDs and webhooks)","step-1-add-the-helm-repository#Step 1: Add the Helm Repository":"helm repo add contextforge https://ctxforge.io helm repo update","step-2-install-contextforge#Step 2: Install ContextForge":"helm install contextforge contextforge/contextforge \\ --namespace ctxforge-system \\ --create-namespace","step-3-verify-the-installation#Step 3: Verify the Installation":"Check that the operator is running:\nkubectl get pods -n ctxforge-system You should see output similar to:\nNAME READY STATUS RESTARTS AGE contextforge-operator-7b9f4d5c6-x2k8p 1/1 Running 0 30s","test-header-propagation#Test Header Propagation":"Send a request with a custom header:\ncurl -H \"x-request-id: test-123\" http://your-service/api/endpoint Check the logs of downstream services ‚Äî they should all receive the x-request-id header!","verify-its-working#Verify It\u0026rsquo;s Working":"After deploying your annotated workload, verify the sidecar was injected:\nkubectl get pod my-service-xxxxx -o jsonpath='{.spec.containers[*].name}' You should see both your app container and the ctxforge-proxy container:\napp ctxforge-proxy"},"title":"Getting Started"},"/docs/how-it-works/":{"data":{"":"This page explains the architecture and internals of ContextForge.","architecture-overview#Architecture Overview":"ContextForge consists of two main components:\nOperator ‚Äî A Kubernetes controller that watches for pod creation and injects the sidecar Proxy Sidecar ‚Äî A lightweight HTTP proxy that handles header propagation flowchart TB subgraph cluster[\"Kubernetes Cluster\"] subgraph operator[\"ContextForge Operator\"] webhook[\"MutatingAdmissionWebhook\"] webhook --\u003e |\"Intercepts Pod creation\"| check[\"Check ctxforge.io/enabled\"] check --\u003e |\"If enabled\"| inject[\"Inject sidecar + HTTP_PROXY\"] end subgraph pod[\"Application Pod\"] proxy[\"ContextForge Proxy:9090\"] app[\"App Container:8080\"] proxy --\u003e |\"Forward requests\"| app end webhook -.-\u003e |\"Patches pod spec\"| pod end style cluster fill:#1e293b,stroke:#6366f1,stroke-width:2px style operator fill:#312e81,stroke:#818cf8,stroke-width:2px style pod fill:#164e63,stroke:#22d3ee,stroke-width:2px style proxy fill:#4c1d95,stroke:#a78bfa style app fill:#0e7490,stroke:#67e8f9","full-chain-propagation#Full Chain Propagation":"flowchart LR subgraph podA[\"Pod A\"] proxyA[\"Proxy\"] appA[\"App A\"] end subgraph podB[\"Pod B\"] proxyB[\"Proxy\"] appB[\"App B\"] end subgraph podC[\"Pod C\"] proxyC[\"Proxy\"] appC[\"App C\"] end Client[\"Clientx-request-id: abc\"] --\u003e proxyA proxyA --\u003e appA appA --\u003e proxyA proxyA --\u003e |\"x-request-id: abc\"| proxyB proxyB --\u003e appB appB --\u003e proxyB proxyB --\u003e |\"x-request-id: abc\"| proxyC proxyC --\u003e appC style podA fill:#312e81,stroke:#818cf8 style podB fill:#312e81,stroke:#818cf8 style podC fill:#312e81,stroke:#818cf8","header-storage#Header Storage":"ContextForge uses Go‚Äôs context.Context for thread-safe, request-scoped header storage:\n// Simplified implementation type contextKey string const ContextKeyHeaders contextKey = \"ctxforge-headers\" // Store headers from incoming request headers := extractHeaders(request, configuredHeaders) ctx := context.WithValue(request.Context(), ContextKeyHeaders, headers) // Retrieve headers for outgoing request if stored := ctx.Value(ContextKeyHeaders); stored != nil { for key, value := range stored.(map[string]string) { outboundRequest.Header.Set(key, value) } }","health-checks#Health Checks":"The proxy exposes health endpoints:\n/healthz ‚Äî Liveness probe (always returns 200) /ready ‚Äî Readiness probe (checks if target app is reachable)","http_proxy-approach#HTTP_PROXY Approach":"ContextForge leverages the standard HTTP_PROXY and HTTPS_PROXY environment variables:\nflowchart LR subgraph pod[\"Your Pod\"] app[\"Application\"] proxy[\"ContextForge Proxylocalhost:9090\"] env[\"ENV: HTTP_PROXY=localhost:9090\"] end app --\u003e |\"All HTTP requestsgo through proxy\"| proxy proxy --\u003e |\"Headers injected\"| external[\"External Services\"] style pod fill:#1e293b,stroke:#6366f1 style proxy fill:#4c1d95,stroke:#a78bfa The operator sets these env vars to point to the sidecar proxy (localhost:9090) Most HTTP clients automatically use these proxies for outgoing requests The proxy intercepts outgoing calls and injects headers Compatibility: This approach works with most HTTP clients in Go, Python, Node.js, Java, Ruby, and other languages. Some clients may require explicit configuration to respect proxy env vars.","incoming-request#Incoming Request":"sequenceDiagram participant Client as External Client participant Proxy as ContextForge Proxy:9090 participant App as Your Application:8080 Client-\u003e\u003eProxy: HTTP Requestx-request-id: abc123x-tenant-id: tenant-1 Note over Proxy: 1. Extract configured headers Note over Proxy: 2. Store in context.Context Proxy-\u003e\u003eApp: Forward request(headers preserved) Note over App: Process business logic App-\u003e\u003eProxy: Response Proxy-\u003e\u003eClient: Response","outgoing-request#Outgoing Request":"When your application makes an HTTP call to another service:\nsequenceDiagram participant App as Your Application participant Proxy as ContextForge Proxy participant ServiceB as Service B Note over App: http.Get(\"http://service-b\")HTTP_PROXY=localhost:9090 App-\u003e\u003eProxy: Outgoing HTTP request Note over Proxy: 1. Intercept request Note over Proxy: 2. Retrieve headers from context Note over Proxy: 3. Inject headers:x-request-id: abc123x-tenant-id: tenant-1 Proxy-\u003e\u003eServiceB: Request with injected headers ServiceB-\u003e\u003eProxy: Response Proxy-\u003e\u003eApp: Response","performance#Performance":"ContextForge is designed for minimal overhead:\nMetric Value Memory per pod ~10MB CPU per pod ~10m Latency overhead \u003c5ms Throughput impact \u003c1%","request-flow#Request Flow":"Here‚Äôs how headers are propagated through a request:","security#Security":"Runs as non-root user (UID 65532) Read-only root filesystem No privileged capabilities required TLS for webhook communication (cert-manager or self-signed)","sidecar-injection-flow#Sidecar Injection Flow":"When you create a pod with the ctxforge.io/enabled: \"true\" annotation:\nsequenceDiagram participant User participant API as Kubernetes API participant Webhook as ContextForge Webhook participant Pod User-\u003e\u003eAPI: kubectl apply -f deployment.yaml API-\u003e\u003eWebhook: Intercept Pod creation Note over Webhook: Check annotation:ctxforge.io/enabled=true Note over Webhook: Extract headers list Note over Webhook: Create sidecar spec Note over Webhook: Add HTTP_PROXY env vars Webhook-\u003e\u003eAPI: Return JSON patch API-\u003e\u003ePod: Create Pod with sidecar Note over Pod: Pod running with:‚Ä¢ App container‚Ä¢ ContextForge proxy"},"title":"How It Works"},"/docs/installation/":{"data":{"":"This guide covers all installation options for ContextForge.","add-the-repository#Add the Repository":"helm repo add contextforge https://ctxforge.io helm repo update","basic-installation#Basic Installation":"helm install contextforge contextforge/contextforge \\ --namespace ctxforge-system \\ --create-namespace","helm-installation#Helm Installation":"","installation-with-custom-values#Installation with Custom Values":"helm install contextforge contextforge/contextforge \\ --namespace ctxforge-system \\ --create-namespace \\ --set operator.replicas=2 \\ --set proxy.image.tag=v0.2.0 \\ --set webhook.failurePolicy=Ignore","manual-installation-kubectl#Manual Installation (kubectl)":"If you prefer not to use Helm, you can install using raw manifests:\n# Install CRDs kubectl apply -f https://raw.githubusercontent.com/bgruszka/contextforge/master/config/crd/bases/ctxforge.ctxforge.io_headerpropagationpolicies.yaml # Install operator kubectl apply -f https://raw.githubusercontent.com/bgruszka/contextforge/master/config/default/","pods-not-getting-sidecar-injected#Pods Not Getting Sidecar Injected":"Check the namespace label:\nkubectl get namespace -o jsonpath='{.metadata.labels}' Ensure ctxforge.io/injection is not set to disabled.\nCheck pod annotations:\nkubectl get pod -o jsonpath='{.metadata.annotations}' Verify ctxforge.io/enabled: \"true\" is present.\nCheck webhook logs:\nkubectl logs -n ctxforge-system deployment/contextforge-operator","requirements#Requirements":"Component Minimum Version Kubernetes 1.24+ Helm 3.0+ cert-manager 1.0+ (optional, for TLS)","troubleshooting#Troubleshooting":"","uninstalling#Uninstalling":"To remove ContextForge:\nhelm uninstall contextforge --namespace ctxforge-system kubectl delete namespace ctxforge-system Uninstalling ContextForge will not remove the sidecar from existing pods. You‚Äôll need to restart those pods after removing the annotations.","upgrading#Upgrading":"To upgrade to a newer version:\nhelm repo update helm upgrade contextforge contextforge/contextforge \\ --namespace ctxforge-system","using-a-values-file#Using a Values File":"Create a values.yaml file:\noperator: replicas: 2 resources: requests: cpu: 100m memory: 128Mi limits: cpu: 500m memory: 256Mi proxy: image: repository: ghcr.io/bgruszka/contextforge-proxy tag: latest resources: requests: cpu: 50m memory: 32Mi limits: cpu: 200m memory: 64Mi webhook: failurePolicy: Fail certManager: enabled: true Install with the values file:\nhelm install contextforge contextforge/contextforge \\ --namespace ctxforge-system \\ --create-namespace \\ -f values.yaml","verify-installation#Verify Installation":"Check the operator is running:\nkubectl get pods -n ctxforge-system kubectl get mutatingwebhookconfigurations | grep contextforge Check the CRD is installed:\nkubectl get crd headerpropagationpolicies.ctxforge.ctxforge.io","webhook-timeouts#Webhook Timeouts":"If pod creation is slow, the webhook might be timing out:\n# Check webhook configuration kubectl get mutatingwebhookconfiguration contextforge-mutating-webhook -o yaml # Increase timeout if needed (via Helm values) webhook: timeoutSeconds: 30"},"title":"Installation"},"/docs/limitations/":{"data":{"":"This page documents known limitations and important considerations when using ContextForge.","grpc#gRPC":"gRPC uses HTTP/2 and typically doesn‚Äôt respect the HTTP_PROXY environment variable. For gRPC header propagation, consider:\nUsing gRPC interceptors in your application Using a service mesh with native gRPC support","header-size-limits#Header Size Limits":"The proxy handles headers up to the standard HTTP limits:\nIndividual header value: 8KB Total headers size: 32KB Headers exceeding these limits may be truncated or rejected.","http-vs-https-comparison#HTTP vs HTTPS Comparison":"flowchart LR subgraph http[\"HTTP Request\"] direction LR C1[Client] --\u003e P1[ContextForgeProxy] P1 --\u003e S1[Service] P1 -.- N1[\"‚úÖ Can read headers‚úÖ Can modify headers‚úÖ Can inject headers\"] end subgraph https[\"HTTPS Request\"] direction LR C2[Client] --\u003e P2[ContextForgeProxy] P2 --\u003e S2[Service] P2 -.- N2[\"‚ùå Cannot read headers‚ùå Cannot modify headers‚ùå CONNECT tunnel only\"] end style http fill:#d4edda,stroke:#28a745 style https fill:#f8d7da,stroke:#dc3545","https-traffic#HTTPS Traffic":"Header propagation only works for HTTP traffic. HTTPS requests cannot have headers injected by the proxy.","performance-overhead#Performance Overhead":"While ContextForge is designed to be lightweight, be aware of:\nScenario Additional Latency Simple request \u003c 1ms With header injection \u003c 2ms Large headers (\u003e 1KB) \u003c 5ms For latency-critical paths where even milliseconds matter, consider whether header propagation is necessary for that specific service.","proxy-aware-clients#Proxy-Aware Clients":"The HTTP_PROXY environment variable approach works with most HTTP clients, but some may require explicit configuration:\nLanguage Status Notes Go (net/http) Works Automatically respects HTTP_PROXY Python (requests) Works Automatically respects HTTP_PROXY Node.js (axios) Works Automatically respects HTTP_PROXY Node.js (fetch) Requires config Use node-fetch with proxy agent Java (HttpClient) Requires config Set system properties Ruby (net/http) Works Automatically respects HTTP_PROXY If your HTTP client doesn‚Äôt respect HTTP_PROXY, you‚Äôll need to configure it explicitly to use http://localhost:9090 as the proxy.","recommendations#Recommendations":"For internal service-to-service communication in Kubernetes:\nUse HTTP internally ‚Äî Most Kubernetes clusters use HTTP for internal traffic, with TLS terminated at the ingress or handled by a service mesh (mTLS)\nService mesh mTLS ‚Äî If you use Istio, Linkerd, or another service mesh for mTLS, the traffic between sidecars is encrypted, but your application still makes plain HTTP calls\nNO_PROXY for external HTTPS ‚Äî If your app needs to call external HTTPS APIs without going through the proxy:\nannotations: ctxforge.io/no-proxy: \"api.external.com,*.googleapis.com\"","single-pod-limitation#Single Pod Limitation":"The proxy stores headers in memory within the request context. This means:\nHeaders are only available within the same request lifecycle Async operations that outlive the request won‚Äôt have access to headers Background jobs triggered by the request won‚Äôt automatically get headers For async scenarios, you‚Äôll need to explicitly pass headers to background workers.","websocket-connections#WebSocket Connections":"WebSocket connections are not supported for header propagation. The initial HTTP upgrade request may go through the proxy, but subsequent WebSocket frames are not HTTP and cannot be modified.","why#Why?":"When applications make HTTPS requests through an HTTP proxy, they use the CONNECT method to establish a TCP tunnel:\nsequenceDiagram participant Client participant Proxy as ContextForge Proxy participant Server as HTTPS Server Client-\u003e\u003eProxy: CONNECT example.com:443 HTTP/1.1 Proxy-\u003e\u003eServer: TCP Connection Proxy--\u003e\u003eClient: HTTP/1.1 200 Connection Established Note over Client,Server: TLS Tunnel Established Client-\u003e\u003eServer: üîí Encrypted TLS Handshake Client-\u003e\u003eServer: üîí Encrypted HTTP Request Server-\u003e\u003eClient: üîí Encrypted HTTP Response Note over Proxy: Cannot see or modifyencrypted traffic Once the TLS tunnel is established, the proxy cannot see or modify the encrypted HTTP headers inside the session. This is a fundamental characteristic of how HTTPS works with HTTP proxies."},"title":"Limitations"}}